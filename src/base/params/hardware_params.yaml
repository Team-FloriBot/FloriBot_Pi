hardware_node:
  ros__parameters:
    wheel_cmd_topic: "/wheel_commands"
    wheel_ticks_topic: "/base/wheel_ticks4"
    ticks_frame_id: "base_link"

    control_dt: 0.02

    # ticks_per_rev: scale to rad (effective)
    ticks_per_rev: 2048.0

    # modulo_ticks: wrap period of raw encoder reading (0..N..0)
    # set this to what you actually see (2000 or 2048)
    modulo_ticks: 2048
    unwrap_enabled: true

    # if /joint_states stalls, stop (prevents "meas=0" spikes)
    jointstate_timeout_s: 0.20

    # PID
    kp: 0.12
    ki: 0.25
    kd: 0.0
    output_limit: 1.0
    deadband: 0.10
    setpoint_max_accel: 6.0
    stop_eps_radps: 0.05

    # measurement processing
    meas_alpha: 0.30
    max_meas_radps: 30.0
    max_tick_jump: 800

    # output smoothing
    u_slew_rate: 3.0

    joint_states_topic: "/joint_states"

    # mapping (as you used with phidgets: joint0..joint3)
    fl_joint: "joint2"
    fr_joint: "joint3"
    rl_joint: "joint0"
    rr_joint: "joint1"

    # you said: FL and RL must be inverted
    invert_fl: true
    invert_fr: false
    invert_rl: true
    invert_rr: false

    i2c_dev: "/dev/i2c-1"
    i2c_addr: 88

    # [FL, FR, RL, RR]
    wheel_channels: [2, 3, 0, 1]
    wheel_gains:    [1.0, 1.0, 1.0, 1.0]

    k_us_per_pct: 5.5
    neutral_us: 1480
    min_us: 900
    max_us: 2100
    pct_min: -100
    pct_max: 100
